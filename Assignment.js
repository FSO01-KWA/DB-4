// MongoDB 기초 및 개념

// 1
// MongoDB는 NoSQL 유형의 데이터베이스이며, 데이터를 BSON(Binary JSON) 형식으로 저장합니다. MongoDB는 스키마가 없으며, 데이터 구조가 고정되지 않아 다양한 형식의 데이터를 유연하게 저장할 수 있습니다.

// 2
// MongoDB에서 문서는 JSON 형식의 데이터 단위를 의미하고, 여러 문서가 모여 컬렉션을 이룹니다. SQL의 테이블과 비교하면, 문서는 테이블의 행과 비슷하고, 컬렉션은 테이블과 비슷합니다. 그러나 MongoDB는 스키마가 없어 같은 컬렉션에 다른 구조의 문서를 저장할 수 있습니다.

// 3
// MongoDB의 스키마리스 특성은 개발 속도를 높이고, 데이터 구조의 유연성을 제공합니다. 그러나 일관성 관리가 어렵고, 데이터 무결성을 보장하기 위해 추가적인 코드 관리가 필요할 수 있습니다.

// 4
// MongoDB는 수평적 확장성을 지원하며, 샤딩을 통해 데이터베이스의 데이터를 여러 샤드로 나누어 저장하여 성능을 향상시킵니다. 샤딩은 각 샤드에 데이터를 분배하고, 쿼리 라우터를 통해 데이터에 접근합니다.

// 5
// MongoDB에서 BSON 형식이 사용되는 이유는 JSON 형식보다 더 빠르고 효율적으로 데이터를 전송하고 저장할 수 있기 때문입니다. BSON은 숫자, 날짜 등 다양한 데이터 타입을 지원하며, 이진 형식으로 컴파일되어 데이터 전송 및 저장 속도가 빠릅니다.

// MongoDB 트랜잭션 관련

// 1
// 멀티 도큐먼트 트랜잭션은 MongoDB에서 여러 문서에 걸친 트랜잭션을 처리하는 기능으로, 특정 작업 단위를 원자적으로 수행할 수 있도록 합니다.

// 2
// MongoDB의 트랜잭션은 ACID 속성을 충족합니다. 원자성(Atomicity)은 모든 작업이 완전하게 수행되거나 전혀 수행되지 않도록 보장합니다. 일관성(Consistency)은 트랜잭션 후 데이터가 유효함을 보장합니다. 고립성(Isolation)은 동시에 실행되는 트랜잭션이 서로 간섭하지 않도록 합니다. 지속성(Durability)은 트랜잭션이 커밋되면 데이터가 손실되지 않음을 보장합니다.

// 3
// `commitTransaction()` 메서드는 트랜잭션을 완료하고, 모든 작업을 커밋하여 데이터 일관성을 유지합니다. `abortTransaction()`은 트랜잭션을 취소하고, 모든 변경을 롤백하여 데이터 상태를 원래대로 되돌립니다.

// 4
// 트랜잭션은 MongoDB 클러스터 환경에서 지원됩니다. 단일 인스턴스에서도 트랜잭션이 가능하지만, 제한적입니다. 트랜잭션을 사용하려면 레플리카 세트 또는 샤딩된 클러스터 환경이 필요합니다.

// 5
// const session = await client.startSession();
// session.startTransaction();
// try {
//     await collection.insertOne({ name: "John" }, { session });
//     await collection.updateOne({ name: "John" }, { $set: { age: 30 } }, { session });
//     await session.commitTransaction();
// } catch (error) {
//     await session.abortTransaction();
// } finally {
//     session.endSession();
// }
// 위의 코드에서는 MongoDB 트랜잭션을 시작하고, 데이터를 삽입 및 업데이트 후 커밋하거나 오류가 발생하면 롤백합니다.

// 샤딩(Sharding) 관련

// 1
// 샤딩은 MongoDB에서 데이터베이스를 여러 개의 샤드로 나누어 분산 저장하여 성능을 최적화하는 기술입니다. 이를 통해 대규모 데이터를 효율적으로 관리할 수 있습니다.

// 2
// 샤드 키는 데이터를 샤드에 분배하는 기준이 됩니다. 샤드 키는 조회 빈도, 데이터 분포 등을 고려하여 선택해야 하며, 부적절한 샤드 키는 성능 저하를 유발할 수 있습니다.

// 3
// 샤딩 구조는 샤드, 쿼리 라우터(mongos), 컨피그 서버로 구성됩니다. 쿼리 라우터는 요청을 받아 샤드에 분배하며, 컨피그 서버는 데이터 배치 및 메타데이터를 관리합니다.

// 4
// Range-based Sharding은 범위를 기준으로 샤드에 데이터를 나누고, Hash-based Sharding은 데이터를 해시 값으로 분배합니다. Range-based는 조회가 빠르지만 불균형한 분배가 발생할 수 있고, Hash-based는 데이터가 고르게 분포되지만 특정 범위 조회가 어렵습니다.

// 5
// 샤딩의 장점은 확장성과 가용성이 높아지는 반면, 설정 및 관리가 복잡할 수 있습니다. 샤딩은 데이터 양이 많거나 높은 성능이 필요한 경우 적합하며, 작은 규모의 데이터베이스에는 적합하지 않을 수 있습니다.

// 레플리카 세트(Replica Set) 관련

// 1
// 레플리카 세트는 MongoDB에서 데이터를 복제하여 가용성과 내결함성을 높이는 기능입니다. 주로 장애 복구 및 백업 목적으로 사용됩니다.

// 2
// Primary는 쓰기 작업을 처리하고, Secondary는 Primary를 복제하며, Arbiter는 투표에 참여해 쿼럼을 유지합니다. Primary 장애 시 Secondary 중 하나가 Primary로 승격됩니다.

// 3
// Primary 서버에 장애가 발생하면, Secondary 서버 중 하나가 자동으로 Primary로 승격되며, 클러스터가 지속적으로 운영됩니다.

// 4
// Secondary 서버를 통한 읽기 작업 분산은 읽기 성능을 향상시키며, 읽기 요청을 여러 서버에 분산하여 처리 속도를 높입니다.

// 5
// 레플리카 세트는 데이터 복제를 통해 가용성을 보장하며, 샤딩은 데이터 분산을 통해 성능을 향상시킵니다. 두 기능을 함께 사용하면 확장성과 가용성을 동시에 확보할 수 있습니다.
